# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `algorithms` gem.
# Please instead update this file by running `bin/tapioca gem algorithms`.


# The 'Algorithms and Containers' library is an effort to provide a set of commonly used
#   algorithms and containers to Ruby programmers.
#
#   This is a Google Summer of Code 2008 project
#
#   Written by Kanwei Li, mentored by Austin Ziegler
#
#   To avoid typing Containers::xxx to initialize containers, include the Containers module.
#
#     require 'algorithms'
#     include Containers
#
#     tree = RBTreeMap.new
#
#   instead of:
#
#     require 'algorithms'
#
#     tree = Containers::RBTreeMap.new
#
#   Done so far:
#   * Heaps           - Containers::Heap, Containers::MaxHeap, Containers::MinHeap
#   * Priority Queue  - Containers::PriorityQueue
#   * Stack           - Containers::Stack
#   * Queue           - Containers::Queue
#   * Deque           - Containers::Deque, Containers::CDeque (C extension), Containers::RubyDeque
#   * Red-Black Trees - Containers::RBTreeMap, Containers::CRBTreeMap (C extension), Containers::RubyRBTreeMap
#   * Splay Trees     - Containers::SplayTreeMap
#   * Tries           - Containers::Trie
#   * Suffix Array    - Containers::SuffixArray
#   * kd Tree         - Containers::KDTree
#
#   * Search algorithms
#     - Binary Search         - Algorithms::Search.binary_search
#     - Knuth-Morris-Pratt    - Algorithms::Search.kmp_search
#   * Sort algorithms
#     - Bubble sort           - Algorithms::Sort.bubble_sort
#     - Comb sort             - Algorithms::Sort.comb_sort
#     - Selection sort        - Algorithms::Sort.selection_sort
#     - Heapsort              - Algorithms::Sort.heapsort
#     - Insertion sort        - Algorithms::Sort.insertion_sort
#     - Shell sort            - Algorithms::Sort.shell_sort
#     - Quicksort             - Algorithms::Sort.quicksort
#     - Mergesort             - Algorithms::Sort.mergesort
#     - Dual-Pivot Quicksort  - Algorithms::Sort.dualpivotquicksort
#   * String algorithms
#     - Levenshtein distance  - Algorithms::String.levenshtein_dist
#
# source://algorithms//lib/algorithms.rb#51
module Algorithms; end

# This module implements search algorithms. Documentation is provided for each algorithm.
#
# source://algorithms//lib/algorithms/search.rb#5
module Algorithms::Search
  # Allows kmp_search to be called as an instance method in classes that include the Search module.
  #
  #   class String; include Algorithms::Search; end
  #   "ABC ABCDAB ABCDABCDABDE".kmp_search("ABCDABD") #=> 15
  #
  # source://algorithms//lib/algorithms/search.rb#80
  def kmp_search(substring); end

  class << self
    # Binary Search: This search finds an item in log(n) time provided that the container is already sorted.
    # The method returns the item if it is found, or nil if it is not. If there are duplicates, the first one
    # found is returned, and this is not guaranteed to be the smallest or largest item.
    #
    # Complexity: O(lg N)
    #
    #   Algorithms::Search.binary_search([1, 2, 3], 1) #=> 1
    #   Algorithms::Search.binary_search([1, 2, 3], 4) #=> nil
    #
    # source://algorithms//lib/algorithms/search.rb#14
    def binary_search(container, item); end

    # Knuth-Morris-Pratt Algorithm substring search algorithm: Efficiently finds the starting position of a
    # substring in a string. The algorithm calculates the best position to resume searching from if a failure
    # occurs.
    #
    # The method returns the index of the starting position in the string where the substring is found. If there
    # is no match, nil is returned.
    #
    # Complexity: O(n + k), where n is the length of the string and k is the length of the substring.
    #
    #   Algorithms::Search.kmp_search("ABC ABCDAB ABCDABCDABDE", "ABCDABD") #=> 15
    #   Algorithms::Search.kmp_search("ABC ABCDAB ABCDABCDABDE", "ABCDEF") #=> nil
    #
    # source://algorithms//lib/algorithms/search.rb#43
    def kmp_search(string, substring); end
  end
end

# This module implements sorting algorithms. Documentation is provided for each algorithm.
#
# source://algorithms//lib/algorithms/sort.rb#7
module Algorithms::Sort
  class << self
    # Bubble sort: A very naive sort that keeps swapping elements until the container is sorted.
    # Requirements: Needs to be able to compare elements with <=>, and the [] []= methods should
    # be implemented for the container.
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.bubble_sort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#16
    def bubble_sort(container); end

    # Comb sort: A variation on bubble sort that dramatically improves performance.
    # Source: http://yagni.com/combsort/
    # Requirements: Needs to be able to compare elements with <=>, and the [] []= methods should
    # be implemented for the container.
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.comb_sort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#39
    def comb_sort(container); end

    # source://algorithms//lib/algorithms/sort.rb#278
    def dualpivot(container, left = T.unsafe(nil), right = T.unsafe(nil), div = T.unsafe(nil)); end

    # source://algorithms//lib/algorithms/sort.rb#364
    def dualpivot_swap(container, i, j); end

    # Dual-Pivot Quicksort is a variation of Quicksort by Vladimir Yaroslavskiy.
    # This is an implementation of the algorithm as it was found in the original
    # research paper:
    #
    # http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf
    #
    # Mirror:
    # http://codeblab.com/wp-content/uploads/2009/09/DualPivotQuicksort.pdf
    #
    # "This algorithm offers O(n log(n)) performance on many data sets that cause
    # other quicksorts to degrade to quadratic performance, and is typically
    # faster than traditional (one-pivot) Quicksort implementations."
    #   -- http://download.oracle.com/javase/7/docs/api/java/util/Arrays.html
    #
    # The algorithm was improved by Vladimir Yaroslavskiy, Jon Bentley, and
    # Joshua Bloch, and was implemented as the default sort algorithm for
    # primatives in Java 7.
    #
    # Implementation in the Java JDK as of November, 2011:
    # http://www.docjar.com/html/api/java/util/DualPivotQuicksort.java.html
    #
    # It is proved that for the Dual-Pivot Quicksort the average number
    # of comparisons is 2*n*ln(n), the average number of swaps is
    # 0.8*n*ln(n), whereas classical Quicksort algorithm has 2*n*ln(n)
    # and 1*n*ln(n) respectively. This has been fully examined mathematically
    # and experimentally.
    #
    # Requirements: Container should implement #pop and include the Enumerable module.
    # Time Complexity: О(n log n) average, О(n log n) worst-case
    # Space Complexity: О(n) auxiliary
    #
    # Stable: No
    #
    #   Algorithms::Sort.dualpivotquicksort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#273
    def dualpivotquicksort(container); end

    # Heap sort: Uses a heap (implemented by the Containers module) to sort the collection.
    # Requirements: Needs to be able to compare elements with <=>
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.heapsort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#85
    def heapsort(container); end

    # Insertion sort: Elements are inserted sequentially into the right position.
    # Requirements: Needs to be able to compare elements with <=>, and the [] []= methods should
    # be implemented for the container.
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.insertion_sort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#100
    def insertion_sort(container); end

    # source://algorithms//lib/algorithms/sort.rb#230
    def merge(left, right); end

    # Mergesort: A stable divide-and-conquer sort that sorts small chunks of the container and then merges them together.
    # Returns an array of the sorted elements.
    # Requirements: Container should implement []
    # Time Complexity: О(n log n) average and worst-case
    # Space Complexity: О(n) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.mergesort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#222
    def mergesort(container); end

    # Quicksort: A divide-and-conquer sort that recursively partitions a container until it is sorted.
    # Requirements: Container should implement #pop and include the Enumerable module.
    # Time Complexity: О(n log n) average, O(n^2) worst-case
    # Space Complexity: О(n) auxiliary
    # Stable: No
    #
    #   Algorithms::Sort.quicksort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    # def self.quicksort(container)
    #   return [] if container.empty?
    #
    #   x, *xs = container
    #
    #   quicksort(xs.select { |i| i <  x }) + [x] + quicksort(xs.select { |i| i >= x })
    # end
    #
    # source://algorithms//lib/algorithms/sort.rb#154
    def partition(data, left, right); end

    # def self.quicksort(container, left = 0, right = container.size - 1)
    #   if left < right
    #     middle = partition(container, left, right)
    #     quicksort(container, left, middle - 1)
    #     quicksort(container, middle + 1, right)
    #   end
    # end
    #
    # source://algorithms//lib/algorithms/sort.rb#180
    def quicksort(container); end

    # Selection sort: A naive sort that goes through the container and selects the smallest element,
    # putting it at the beginning. Repeat until the end is reached.
    # Requirements: Needs to be able to compare elements with <=>, and the [] []= methods should
    # be implemented for the container.
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.selection_sort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#67
    def selection_sort(container); end

    # Shell sort: Similar approach as insertion sort but slightly better.
    # Requirements: Needs to be able to compare elements with <=>, and the [] []= methods should
    # be implemented for the container.
    # Time Complexity: О(n^2)
    # Space Complexity: О(n) total, O(1) auxiliary
    # Stable: Yes
    #
    #   Algorithms::Sort.shell_sort [5, 4, 3, 1, 2] => [1, 2, 3, 4, 5]
    #
    # source://algorithms//lib/algorithms/sort.rb#122
    def shell_sort(container); end
  end
end

module Algorithms::String
  class << self
    def levenshtein_dist(_arg0, _arg1); end
  end
end

# source://algorithms//lib/algorithms.rb#52
module Containers; end

class Containers::CDeque
  include ::Enumerable

  def initialize(*_arg0); end

  def back; end
  def clear; end
  def each; end
  def each_backward; end
  def each_forward; end
  def empty?; end
  def front; end
  def length; end
  def pop_back; end
  def pop_front; end
  def push_back(_arg0); end
  def push_front(_arg0); end
  def reverse_each; end
  def size; end
end

class Containers::CRBTreeMap
  include ::Enumerable

  def initialize; end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def delete(_arg0); end
  def delete_max; end
  def delete_min; end
  def each; end
  def empty?; end
  def get(_arg0); end
  def has_key?(_arg0); end
  def height; end
  def max_key; end
  def min_key; end
  def push(_arg0, _arg1); end
  def size; end
end

class Containers::CSplayTreeMap
  include ::Enumerable

  def initialize; end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clear; end
  def delete(_arg0); end
  def each; end
  def empty?; end
  def get(_arg0); end
  def has_key?(_arg0); end
  def height; end
  def max_key; end
  def min_key; end
  def push(_arg0, _arg1); end
  def size; end
end

# source://algorithms//lib/containers/deque.rb#168
Containers::Deque = Containers::CDeque

# A Heap is a container that satisfies the heap property that nodes are always smaller in
#     value than their parent node.
#
#     The Containers::Heap class is flexible and upon initialization, takes an optional block
#     that determines how the items are ordered. Two versions that are included are the
#     Containers::MaxHeap and Containers::MinHeap that return the largest and smallest items on
#     each invocation, respectively.
#
#     This library implements a Fibonacci heap, which allows O(1) complexity for most methods.
#
# source://algorithms//lib/containers/heap.rb#12
class Containers::Heap
  include ::Enumerable

  # call-seq:
  #     Heap.new(optional_array) { |x, y| optional_comparison_fn } -> new_heap
  #
  # If an optional array is passed, the entries in the array are inserted into the heap with
  # equal key and value fields. Also, an optional block can be passed to define the function
  # that maintains heap property. For example, a min-heap can be created with:
  #
  #     minheap = Heap.new { |x, y| (x <=> y) == -1 }
  #     minheap.push(6)
  #     minheap.push(10)
  #     minheap.pop #=> 6
  #
  # Thus, smaller elements will be parent nodes. The heap defaults to a min-heap if no block
  # is given.
  #
  # @return [Heap] a new instance of Heap
  #
  # source://algorithms//lib/containers/heap.rb#38
  def initialize(ary = T.unsafe(nil), &block); end

  # call-seq:
  #     push(key, value) -> value
  #     push(value) -> value
  #
  # Inserts an item with a given key into the heap. If only one parameter is given,
  # the key is set to the value.
  #
  # Complexity: O(1)
  #
  #     heap = MinHeap.new
  #     heap.push(1, "Cat")
  #     heap.push(2)
  #     heap.pop #=> "Cat"
  #     heap.pop #=> 2
  #
  # @raise [ArgumentError]
  #
  # source://algorithms//lib/containers/heap.rb#61
  def <<(key, value = T.unsafe(nil)); end

  # call-seq:
  #     change_key(key, new_key) -> [new_key, value]
  #     change_key(key, new_key) -> nil
  #
  # Changes the key from one to another. Doing so must not violate the heap property or
  # an exception will be raised. If the key is found, an array containing the new key and
  # value pair is returned, otherwise nil is returned.
  #
  # In the case of duplicate keys, an arbitrary key is changed. This will be investigated
  # more in the future.
  #
  # Complexity: amortized O(1)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.change_key(2, 3) #=> raise error since we can't increase the value in a min-heap
  #     minheap.change_key(2, 0) #=> [0, 2]
  #     minheap.pop #=> 2
  #     minheap.pop #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#255
  def change_key(key, new_key, delete = T.unsafe(nil)); end

  # call-seq:
  #     clear -> nil
  #
  # Removes all elements from the heap, destructively.
  #
  # Complexity: O(1)
  #
  # source://algorithms//lib/containers/heap.rb#136
  def clear; end

  # call-seq:
  #     delete(key) -> value
  #     delete(key) -> nil
  #
  # Deletes the item with associated key and returns it. nil is returned if the key
  # is not found. In the case of nodes with duplicate keys, an arbitrary one is deleted.
  #
  # Complexity: amortized O(log n)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.delete(1) #=> 1
  #     minheap.size #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#293
  def delete(key); end

  # call-seq:
  #     empty? -> true or false
  #
  # Returns true if the heap is empty, false otherwise.
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/heap.rb#147
  def empty?; end

  # call-seq:
  #     has_key?(key) -> true or false
  #
  # Returns true if heap contains the key.
  #
  # Complexity: O(1)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.has_key?(2) #=> true
  #     minheap.has_key?(4) #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/heap.rb#94
  def has_key?(key); end

  # call-seq:
  #     size -> int
  #
  # Return the number of elements in the heap.
  #
  # source://algorithms//lib/containers/heap.rb#19
  def length; end

  # call-seq:
  #     merge!(otherheap) -> merged_heap
  #
  # Does a shallow merge of all the nodes in the other heap.
  #
  # Complexity: O(1)
  #
  #     heap = MinHeap.new([5, 6, 7, 8])
  #     otherheap = MinHeap.new([1, 2, 3, 4])
  #     heap.merge!(otherheap)
  #     heap.size #=> 8
  #     heap.pop #=> 1
  #
  # @raise [ArgumentError]
  #
  # source://algorithms//lib/containers/heap.rb#163
  def merge!(otherheap); end

  # call-seq:
  #     next -> value
  #     next -> nil
  #
  # Returns the value of the next item in heap order, but does not remove it.
  #
  # Complexity: O(1)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.next #=> 1
  #     minheap.size #=> 2
  #
  # source://algorithms//lib/containers/heap.rb#109
  def next; end

  # call-seq:
  #     pop -> value
  #     pop -> nil
  #
  # Returns the value of the next item in heap order and removes it from the heap.
  #
  # Complexity: O(1)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.pop #=> 1
  #     minheap.size #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#191
  def next!; end

  # call-seq:
  #     next_key -> key
  #     next_key -> nil
  #
  # Returns the key associated with the next item in heap order, but does not remove the value.
  #
  # Complexity: O(1)
  #
  #     minheap = MinHeap.new
  #     minheap.push(1, :a)
  #     minheap.next_key #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#125
  def next_key; end

  # call-seq:
  #     pop -> value
  #     pop -> nil
  #
  # Returns the value of the next item in heap order and removes it from the heap.
  #
  # Complexity: O(1)
  #
  #     minheap = MinHeap.new([1, 2])
  #     minheap.pop #=> 1
  #     minheap.size #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#191
  def pop; end

  # call-seq:
  #     push(key, value) -> value
  #     push(value) -> value
  #
  # Inserts an item with a given key into the heap. If only one parameter is given,
  # the key is set to the value.
  #
  # Complexity: O(1)
  #
  #     heap = MinHeap.new
  #     heap.push(1, "Cat")
  #     heap.push(2)
  #     heap.pop #=> "Cat"
  #     heap.pop #=> 2
  #
  # @raise [ArgumentError]
  #
  # source://algorithms//lib/containers/heap.rb#61
  def push(key, value = T.unsafe(nil)); end

  # call-seq:
  #     size -> int
  #
  # Return the number of elements in the heap.
  #
  # source://algorithms//lib/containers/heap.rb#19
  def size; end

  private

  # source://algorithms//lib/containers/heap.rb#379
  def cascading_cut(node); end

  # Makes sure the structure does not contain nodes in the root list with equal degrees
  #
  # source://algorithms//lib/containers/heap.rb#340
  def consolidate; end

  # remove x from y's children and add x to the root list
  #
  # source://algorithms//lib/containers/heap.rb#393
  def cut(x, y); end

  # make node a child of a parent node
  #
  # source://algorithms//lib/containers/heap.rb#317
  def link_nodes(child, parent); end
end

# Node class used internally
#
# source://algorithms//lib/containers/heap.rb#298
class Containers::Heap::Node
  # @return [Node] a new instance of Node
  #
  # source://algorithms//lib/containers/heap.rb#301
  def initialize(key, value); end

  # source://algorithms//lib/containers/heap.rb#299
  def child; end

  # source://algorithms//lib/containers/heap.rb#299
  def child=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def degree; end

  # source://algorithms//lib/containers/heap.rb#299
  def degree=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def key; end

  # source://algorithms//lib/containers/heap.rb#299
  def key=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def left; end

  # source://algorithms//lib/containers/heap.rb#299
  def left=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def marked; end

  # source://algorithms//lib/containers/heap.rb#299
  def marked=(_arg0); end

  # @return [Boolean]
  #
  # source://algorithms//lib/containers/heap.rb#310
  def marked?; end

  # source://algorithms//lib/containers/heap.rb#299
  def parent; end

  # source://algorithms//lib/containers/heap.rb#299
  def parent=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def right; end

  # source://algorithms//lib/containers/heap.rb#299
  def right=(_arg0); end

  # source://algorithms//lib/containers/heap.rb#299
  def value; end

  # source://algorithms//lib/containers/heap.rb#299
  def value=(_arg0); end
end

# A kd-tree is a binary tree that allows one to store points (of any space dimension: 2D, 3D, etc).
#     The structure of the resulting tree makes it so that large portions of the tree are pruned
#     during queries.
#
#     One very good use of the tree is to allow nearest neighbor searching. Let's say you have a number
#     of points in 2D space, and you want to find the nearest 2 points from a specific point:
#
#     First, put the points into the tree:
#
#       kdtree = Containers::KDTree.new( {0 => [4, 3], 1 => [3, 4], 2 => [-1, 2], 3 => [6, 4],
#                                        4 => [3, -5], 5 => [-2, -5] })
#
#     Then, query on the tree:
#
#       puts kd.find_nearest([0, 0], 2) => [[5, 2], [9, 1]]
#
#     The result is an array of [distance, id] pairs. There seems to be a bug in this version.
#
#     Note that the point queried on does not have to exist in the tree. However, if it does exist,
#     it will be returned.
#
# source://algorithms//lib/containers/kd_tree.rb#26
class Containers::KDTree
  # Points is a hash of id => [coord, coord] pairs.
  #
  # @return [KDTree] a new instance of KDTree
  #
  # source://algorithms//lib/containers/kd_tree.rb#30
  def initialize(points); end

  # Find k closest points to given coordinates
  #
  # source://algorithms//lib/containers/kd_tree.rb#38
  def find_nearest(target, k_nearest); end

  private

  # points is an array
  #
  # source://algorithms//lib/containers/kd_tree.rb#44
  def build_tree(points, depth = T.unsafe(nil)); end

  # Update array of nearest elements if necessary
  #
  # source://algorithms//lib/containers/kd_tree.rb#69
  def check_nearest(nearest, node, target, k_nearest); end

  # Euclidian distanced, squared, between a node and target coords
  #
  # source://algorithms//lib/containers/kd_tree.rb#60
  def distance2(node, target); end

  # Recursively find nearest coordinates, going down the appropriate branch as needed
  #
  # source://algorithms//lib/containers/kd_tree.rb#81
  def nearest(node, target, k_nearest, depth); end
end

# source://algorithms//lib/containers/kd_tree.rb#27
class Containers::KDTree::Node < ::Struct
  # Returns the value of attribute coords
  #
  # @return [Object] the current value of coords
  def coords; end

  # Sets the attribute coords
  #
  # @param value [Object] the value to set the attribute coords to.
  # @return [Object] the newly set value
  def coords=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute left
  #
  # @return [Object] the current value of left
  def left; end

  # Sets the attribute left
  #
  # @param value [Object] the value to set the attribute left to.
  # @return [Object] the newly set value
  def left=(_); end

  # Returns the value of attribute right
  #
  # @return [Object] the current value of right
  def right; end

  # Sets the attribute right
  #
  # @param value [Object] the value to set the attribute right to.
  # @return [Object] the newly set value
  def right=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A MaxHeap is a heap where the items are returned in descending order of key value.
#
# source://algorithms//lib/containers/heap.rb#414
class Containers::MaxHeap < ::Containers::Heap
  # call-seq:
  #     MaxHeap.new(ary) -> new_heap
  #
  # Creates a new MaxHeap with an optional array parameter of items to insert into the heap.
  # A MaxHeap is created by calling Heap.new { |x, y| (x <=> y) == 1 }, so this is a convenience class.
  #
  #     maxheap = MaxHeap.new([1, 2, 3, 4])
  #     maxheap.pop #=> 4
  #     maxheap.pop #=> 3
  #
  # @return [MaxHeap] a new instance of MaxHeap
  #
  # source://algorithms//lib/containers/heap.rb#425
  def initialize(ary = T.unsafe(nil)); end

  # call-seq:
  #     max -> value
  #     max -> nil
  #
  # Returns the item with the largest key, but does not remove it from the heap.
  #
  #     maxheap = MaxHeap.new([1, 2, 3, 4])
  #     maxheap.max #=> 4
  #
  # source://algorithms//lib/containers/heap.rb#437
  def max; end

  # call-seq:
  #     max! -> value
  #     max! -> nil
  #
  # Returns the item with the largest key and removes it from the heap.
  #
  #     maxheap = MaxHeap.new([1, 2, 3, 4])
  #     maxheap.max! #=> 4
  #     maxheap.size #=> 3
  #
  # source://algorithms//lib/containers/heap.rb#450
  def max!; end
end

# A MinHeap is a heap where the items are returned in ascending order of key value.
#
# source://algorithms//lib/containers/heap.rb#456
class Containers::MinHeap < ::Containers::Heap
  # call-seq:
  #     MinHeap.new(ary) -> new_heap
  #
  # Creates a new MinHeap with an optional array parameter of items to insert into the heap.
  # A MinHeap is created by calling Heap.new { |x, y| (x <=> y) == -1 }, so this is a convenience class.
  #
  #     minheap = MinHeap.new([1, 2, 3, 4])
  #     minheap.pop #=> 1
  #     minheap.pop #=> 2
  #
  # @return [MinHeap] a new instance of MinHeap
  #
  # source://algorithms//lib/containers/heap.rb#467
  def initialize(ary = T.unsafe(nil)); end

  # call-seq:
  #     min -> value
  #     min -> nil
  #
  # Returns the item with the smallest key, but does not remove it from the heap.
  #
  #     minheap = MinHeap.new([1, 2, 3, 4])
  #     minheap.min #=> 1
  #
  # source://algorithms//lib/containers/heap.rb#479
  def min; end

  # call-seq:
  #     min! -> value
  #     min! -> nil
  #
  # Returns the item with the smallest key and removes it from the heap.
  #
  #     minheap = MinHeap.new([1, 2, 3, 4])
  #     minheap.min! #=> 1
  #     minheap.size #=> 3
  #
  # source://algorithms//lib/containers/heap.rb#492
  def min!; end
end

# A Priority Queue is a data structure that behaves like a queue except that elements have an
#     associated priority. The #next and #pop methods return the item with the next highest priority.
#
#     Priority Queues are often used in graph problems, such as Dijkstra's Algorithm for shortest
#     path, and the A* search algorithm for shortest path.
#
#     This container is implemented using the Fibonacci heap included in the Collections library.
#
# source://algorithms//lib/containers/priority_queue.rb#12
class Containers::PriorityQueue
  include ::Enumerable

  # Create a new, empty PriorityQueue
  #
  # @return [PriorityQueue] a new instance of PriorityQueue
  #
  # source://algorithms//lib/containers/priority_queue.rb#16
  def initialize(&block); end

  # Clears all the items in the queue.
  #
  # source://algorithms//lib/containers/priority_queue.rb#43
  def clear; end

  # call-seq:
  #     delete(priority) -> object
  #     delete(priority) -> nil
  #
  # Delete an object with specified priority from the queue. If there are duplicates, an
  # arbitrary object with that priority is deleted and returned. Returns nil if there are
  # no objects with the priority.
  #
  #     q = PriorityQueue.new
  #     q.push("Alaska", 50)
  #     q.push("Delaware", 30)
  #     q.delete(50)            #=> "Alaska"
  #     q.delete(10)            #=> nil
  #
  # source://algorithms//lib/containers/priority_queue.rb#109
  def delete(priority); end

  # Returns true if the queue is empty, false otherwise.
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/priority_queue.rb#48
  def empty?; end

  # call-seq:
  #     has_priority? priority -> boolean
  #
  # Return true if the priority is in the queue, false otherwise.
  #
  #     q = PriorityQueue.new
  #     q.push("Alaska", 1)
  #
  #     q.has_priority?(1)    #=> true
  #     q.has_priority?(2)    #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/priority_queue.rb#62
  def has_priority?(priority); end

  # Returns the number of elements in the queue.
  #
  #    q = Containers::PriorityQueue.new
  #    q.size #=> 0
  #    q.push("Alaska", 1)
  #    q.size #=> 1
  #
  # source://algorithms//lib/containers/priority_queue.rb#28
  def length; end

  # call-seq:
  #     next -> object
  #
  # Return the object with the next highest priority, but does not remove it
  #
  #     q = Containers::PriorityQueue.new
  #     q.push("Alaska", 50)
  #     q.push("Delaware", 30)
  #     q.push("Georgia", 35)
  #     q.next          #=> "Alaska"
  #
  # source://algorithms//lib/containers/priority_queue.rb#76
  def next; end

  # call-seq:
  #     pop -> object
  #
  # Return the object with the next highest priority and removes it from the queue
  #
  #     q = Containers::PriorityQueue.new
  #     q.push("Alaska", 50)
  #     q.push("Delaware", 30)
  #     q.push("Georgia", 35)
  #     q.pop         #=> "Alaska"
  #     q.size        #=> 2
  #
  # source://algorithms//lib/containers/priority_queue.rb#91
  def next!; end

  # call-seq:
  #     pop -> object
  #
  # Return the object with the next highest priority and removes it from the queue
  #
  #     q = Containers::PriorityQueue.new
  #     q.push("Alaska", 50)
  #     q.push("Delaware", 30)
  #     q.push("Georgia", 35)
  #     q.pop         #=> "Alaska"
  #     q.size        #=> 2
  #
  # source://algorithms//lib/containers/priority_queue.rb#91
  def pop; end

  # Add an object to the queue with associated priority.
  #
  #   q = Containers::PriorityQueue.new
  #   q.push("Alaska", 1)
  #   q.pop #=> "Alaska"
  #
  # source://algorithms//lib/containers/priority_queue.rb#38
  def push(object, priority); end

  # Returns the number of elements in the queue.
  #
  #    q = Containers::PriorityQueue.new
  #    q.size #=> 0
  #    q.push("Alaska", 1)
  #    q.size #=> 1
  #
  # source://algorithms//lib/containers/priority_queue.rb#28
  def size; end
end

# A Queue is a container that keeps elements in a first-in first-out (FIFO) order. Because of its
#     properties, it is often used as a buffer.
#
#     This implementation uses a doubly-linked list, guaranteeing O(1) complexity for all operations.
#
# source://algorithms//lib/containers/queue.rb#10
class Containers::Queue
  include ::Enumerable

  # Create a new queue. Takes an optional array argument to initialize the queue.
  #
  #   q = Containers::Queue.new([1, 2, 3])
  #   q.pop #=> 1
  #   q.pop #=> 2
  #
  # @return [Queue] a new instance of Queue
  #
  # source://algorithms//lib/containers/queue.rb#17
  def initialize(ary = T.unsafe(nil)); end

  # Adds an item to the queue.
  #
  #   q = Containers::Queue.new([1])
  #   q.push(2)
  #   q.pop #=> 1
  #   q.pop #=> 2
  #
  # source://algorithms//lib/containers/queue.rb#36
  def <<(obj); end

  # Iterate over the Queue in FIFO order.
  #
  # source://algorithms//lib/containers/queue.rb#64
  def each(&block); end

  # Returns true if the queue is empty, false otherwise.
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/queue.rb#59
  def empty?; end

  # Returns the next item from the queue but does not remove it.
  #
  #   q = Containers::Queue.new([1, 2, 3])
  #   q.next #=> 1
  #   q.size #=> 3
  #
  # source://algorithms//lib/containers/queue.rb#26
  def next; end

  # Removes the next item from the queue and returns it.
  #
  #   q = Containers::Queue.new([1, 2, 3])
  #   q.pop #=> 1
  #   q.size #=> 2
  #
  # source://algorithms//lib/containers/queue.rb#46
  def pop; end

  # Adds an item to the queue.
  #
  #   q = Containers::Queue.new([1])
  #   q.push(2)
  #   q.pop #=> 1
  #   q.pop #=> 2
  #
  # source://algorithms//lib/containers/queue.rb#36
  def push(obj); end

  # Return the number of items in the queue.
  #
  #   q = Containers::Queue.new([1, 2, 3])
  #   q.size #=> 3
  #
  # source://algorithms//lib/containers/queue.rb#54
  def size; end
end

# source://algorithms//lib/containers/rb_tree_map.rb#395
Containers::RBTreeMap = Containers::CRBTreeMap

# A Deque is a container that allows items to be added and removed from both the front and back,
#     acting as a combination of a Stack and Queue.
#
#     This implementation uses a doubly-linked list, guaranteeing O(1) complexity for all operations.
#
# source://algorithms//lib/containers/deque.rb#7
class Containers::RubyDeque
  include ::Enumerable

  # Create a new Deque. Takes an optional array argument to initialize the Deque.
  #
  #   d = Containers::Deque.new([1, 2, 3])
  #   d.front #=> 1
  #   d.back #=> 3
  #
  # @return [RubyDeque] a new instance of RubyDeque
  #
  # source://algorithms//lib/containers/deque.rb#17
  def initialize(ary = T.unsafe(nil)); end

  # Returns the object at the back of the Deque but does not remove it.
  #
  #   d = Containers::Deque.new
  #   d.push_front(1)
  #   d.push_front(2)
  #   d.back #=> 1
  #
  # source://algorithms//lib/containers/deque.rb#60
  def back; end

  # Removes all the objects in the Deque.
  #
  # source://algorithms//lib/containers/deque.rb#30
  def clear; end

  # Iterate over the Deque in FIFO order.
  #
  # source://algorithms//lib/containers/deque.rb#143
  def each; end

  # Iterate over the Deque in LIFO order.
  #
  # source://algorithms//lib/containers/deque.rb#154
  def each_backward; end

  # Iterate over the Deque in FIFO order.
  #
  # source://algorithms//lib/containers/deque.rb#143
  def each_forward; end

  # Returns true if the Deque is empty, false otherwise.
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/deque.rb#25
  def empty?; end

  # Returns the object at the front of the Deque but does not remove it.
  #
  #   d = Containers::Deque.new
  #   d.push_front(1)
  #   d.push_front(2)
  #   d.front #=> 2
  #
  # source://algorithms//lib/containers/deque.rb#50
  def front; end

  # Return the number of items in the Deque.
  #
  #   d = Containers::Deque.new([1, 2, 3])
  #   d.size #=> 3
  #
  # source://algorithms//lib/containers/deque.rb#39
  def length; end

  # Returns the object at the back of the Deque and removes it.
  #
  #   d = Containers::Deque.new
  #   d.push_front(1)
  #   d.push_front(2)
  #   d.pop_back #=> 1
  #   d.size #=> 1
  #
  # source://algorithms//lib/containers/deque.rb#128
  def pop_back; end

  # Returns the object at the front of the Deque and removes it.
  #
  #   d = Containers::Deque.new
  #   d.push_front(1)
  #   d.push_front(2)
  #   d.pop_front #=> 2
  #   d.size #=> 1
  #
  # source://algorithms//lib/containers/deque.rb#107
  def pop_front; end

  # Adds an object at the back of the Deque.
  #
  #   d = Containers::Deque.new([1, 2, 3])
  #   d.push_back(4)
  #   d.pop_back #=> 4
  #
  # source://algorithms//lib/containers/deque.rb#87
  def push_back(obj); end

  # Adds an object at the front of the Deque.
  #
  #   d = Containers::Deque.new([1, 2, 3])
  #   d.push_front(0)
  #   d.pop_front #=> 0
  #
  # source://algorithms//lib/containers/deque.rb#69
  def push_front(obj); end

  # Iterate over the Deque in LIFO order.
  #
  # source://algorithms//lib/containers/deque.rb#154
  def reverse_each; end

  # Return the number of items in the Deque.
  #
  #   d = Containers::Deque.new([1, 2, 3])
  #   d.size #=> 3
  #
  # source://algorithms//lib/containers/deque.rb#39
  def size; end
end

# source://algorithms//lib/containers/deque.rb#10
class Containers::RubyDeque::Node < ::Struct
  # Returns the value of attribute left
  #
  # @return [Object] the current value of left
  def left; end

  # Sets the attribute left
  #
  # @param value [Object] the value to set the attribute left to.
  # @return [Object] the newly set value
  def left=(_); end

  # Returns the value of attribute obj
  #
  # @return [Object] the current value of obj
  def obj; end

  # Sets the attribute obj
  #
  # @param value [Object] the value to set the attribute obj to.
  # @return [Object] the newly set value
  def obj=(_); end

  # Returns the value of attribute right
  #
  # @return [Object] the current value of right
  def right; end

  # Sets the attribute right
  #
  # @param value [Object] the value to set the attribute right to.
  # @return [Object] the newly set value
  def right=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A RBTreeMap is a map that is stored in sorted order based on the order of its keys. This ordering is
#     determined by applying the function <=> to compare the keys. No duplicate values for keys are allowed,
#     so duplicate values are overwritten.
#
#     A major advantage of RBTreeMap over a Hash is the fact that keys are stored in order and can thus be
#     iterated over in order. This is useful for many datasets.
#
#     The implementation is adapted from Robert Sedgewick's Left Leaning Red-Black Tree implementation,
#     which can be found at http://www.cs.princeton.edu/~rs/talks/LLRB/Java/RedBlackBST.java
#
#     Containers::RBTreeMap automatically uses the faster C implementation if it was built
#     when the gem was installed. Alternatively, Containers::RubyRBTreeMap and Containers::CRBTreeMap can be
#     explicitly used as well; their functionality is identical.
#
#     Most methods have O(log n) complexity.
#
# source://algorithms//lib/containers/rb_tree_map.rb#20
class Containers::RubyRBTreeMap
  include ::Enumerable

  # Create and initialize a new empty TreeMap.
  #
  # @return [RubyRBTreeMap] a new instance of RubyRBTreeMap
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#26
  def initialize; end

  # Return the item associated with the key, or nil if none found.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.get("GA") #=> "Georgia"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#89
  def [](key); end

  # Insert an item with an associated key into the TreeMap, and returns the item inserted
  #
  # Complexity: O(log n)
  #
  # map = Containers::TreeMap.new
  # map.push("MA", "Massachusetts") #=> "Massachusetts"
  # map.get("MA") #=> "Massachusetts"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#38
  def []=(key, value); end

  # Deletes the item and key if it's found, and returns the item. Returns nil
  # if key is not present.
  #
  # !!! Warning !!! There is a currently a bug in the delete method that occurs rarely
  # but often enough, especially in large datasets. It is currently under investigation.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.min_key #=> "GA"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#130
  def delete(key); end

  # Deletes the item with the largest key and returns the item. Returns nil
  # if key is not present.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.delete_max #=> "Georgia"
  #   map.size #=> 1
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#173
  def delete_max; end

  # Deletes the item with the smallest key and returns the item. Returns nil
  # if key is not present.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.delete_min #=> "Massachusetts"
  #   map.size #=> 1
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#154
  def delete_min; end

  # Iterates over the TreeMap from smallest to largest element. Iterative approach.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#183
  def each; end

  # Returns true if the tree is empty, false otherwise
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#140
  def empty?; end

  # Return the item associated with the key, or nil if none found.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.get("GA") #=> "Georgia"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#89
  def get(key); end

  # Return true if key is found in the TreeMap, false otherwise
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.has_key?("GA") #=> true
  #   map.has_key?("DE") #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#77
  def has_key?(key); end

  # Return the height of the tree structure in the TreeMap.
  #
  # Complexity: O(1)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.height #=> 2
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#64
  def height; end

  # Returns the value of attribute height_black.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#23
  def height_black; end

  # Sets the attribute height_black
  #
  # @param value the value to set the attribute height_black to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#23
  def height_black=(_arg0); end

  # Return the largest key in the map.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.max_key #=> "MA"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#114
  def max_key; end

  # Return the smallest key in the map.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.min_key #=> "GA"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#102
  def min_key; end

  # Insert an item with an associated key into the TreeMap, and returns the item inserted
  #
  # Complexity: O(log n)
  #
  # map = Containers::TreeMap.new
  # map.push("MA", "Massachusetts") #=> "Massachusetts"
  # map.get("MA") #=> "Massachusetts"
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#38
  def push(key, value); end

  # Return the number of items in the TreeMap.
  #
  #   map = Containers::TreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.size #=> 2
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#52
  def size; end

  private

  # source://algorithms//lib/containers/rb_tree_map.rb#331
  def delete_max_recursive(node); end

  # source://algorithms//lib/containers/rb_tree_map.rb#318
  def delete_min_recursive(node); end

  # source://algorithms//lib/containers/rb_tree_map.rb#293
  def delete_recursive(node, key); end

  # source://algorithms//lib/containers/rb_tree_map.rb#345
  def get_recursive(node, key); end

  # source://algorithms//lib/containers/rb_tree_map.rb#369
  def insert(node, key, value); end

  # source://algorithms//lib/containers/rb_tree_map.rb#385
  def isred(node); end

  # source://algorithms//lib/containers/rb_tree_map.rb#362
  def max_recursive(node); end

  # source://algorithms//lib/containers/rb_tree_map.rb#355
  def min_recursive(node); end
end

# source://algorithms//lib/containers/rb_tree_map.rb#203
class Containers::RubyRBTreeMap::Node
  # @return [Node] a new instance of Node
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#205
  def initialize(key, value); end

  # Returns the value of attribute color.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def color; end

  # Sets the attribute color
  #
  # @param value the value to set the attribute color to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def color=(_arg0); end

  # source://algorithms//lib/containers/rb_tree_map.rb#219
  def colorflip; end

  # source://algorithms//lib/containers/rb_tree_map.rb#284
  def fixup; end

  # Returns the value of attribute height.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def height; end

  # Sets the attribute height
  #
  # @param value the value to set the attribute height to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def height=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def key=(_arg0); end

  # Returns the value of attribute left.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def left=(_arg0); end

  # source://algorithms//lib/containers/rb_tree_map.rb#265
  def move_red_left; end

  # source://algorithms//lib/containers/rb_tree_map.rb#275
  def move_red_right; end

  # @return [Boolean]
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#215
  def red?; end

  # Returns the value of attribute right.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def right=(_arg0); end

  # source://algorithms//lib/containers/rb_tree_map.rb#237
  def rotate_left; end

  # source://algorithms//lib/containers/rb_tree_map.rb#251
  def rotate_right; end

  # Returns the value of attribute size.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def size=(_arg0); end

  # source://algorithms//lib/containers/rb_tree_map.rb#225
  def update_size; end

  # Returns the value of attribute value.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://algorithms//lib/containers/rb_tree_map.rb#204
  def value=(_arg0); end
end

# A SplayTreeMap is a map that is stored in ascending order of its keys, determined by applying
#     the function <=> to compare keys. No duplicate values for keys are allowed, so new values of a key
#     overwrites the old value of the key.
#
#     A major advantage of SplayTreeMap over a Hash is the fact that keys are stored in order and can thus be
#     iterated over in order. Also, Splay Trees are self-optimizing as recently accessed nodes stay near
#     the root and are easily re-accessed later. Splay Trees are also more simply implemented than Red-Black
#     trees.
#
#     Splay trees have amortized O(log n) performance for most methods, but are O(n) worst case. This happens
#     when keys are added in sorted order, causing the tree to have a height of the number of items added.
#
# source://algorithms//lib/containers/splay_tree_map.rb#16
class Containers::RubySplayTreeMap
  include ::Enumerable

  # Create and initialize a new empty SplayTreeMap.
  #
  # @return [RubySplayTreeMap] a new instance of RubySplayTreeMap
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#22
  def initialize; end

  # Return the item associated with the key, or nil if none found.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.get("GA") #=> "Georgia"
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#116
  def [](key); end

  # Insert an item with an associated key into the SplayTreeMap, and returns the item inserted
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts") #=> "Massachusetts"
  #   map.get("MA") #=> "Massachusetts"
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#34
  def []=(key, value); end

  # Remove all elements from the SplayTreeMap
  #
  # Complexity: O(1)
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#77
  def clear; end

  # Deletes the item and key if it's found, and returns the item. Returns nil
  # if key is not present.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map["MA"] = "Massachusetts"
  #   map["GA"] = "Georgia"
  #   map.delete("GA") #=> "Georgia"
  #   map.delete("DE") #=> nil
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#170
  def delete(key); end

  # Iterates over the SplayTreeMap in ascending order. Uses an iterative, not recursive, approach.
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#189
  def each; end

  # Return the item associated with the key, or nil if none found.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.get("GA") #=> "Georgia"
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#116
  def get(key); end

  # Return true if key is found in the SplayTreeMap, false otherwise.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map["MA"] = "Massachusetts"
  #   map["GA"] = "Georgia"
  #   map.has_key?("GA") #=> true
  #   map.has_key?("DE") #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#104
  def has_key?(key); end

  # Return the height of the tree structure in the SplayTreeMap.
  #
  # Complexity: O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.height #=> 2
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#91
  def height; end

  # Return the largest [key, value] pair in the SplayTreeMap, or nil if the tree is empty.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map["MA"] = "Massachusetts"
  #   map["GA"] = "Georgia"
  #   map.max #=> ["MA", "Massachusetts"]
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#150
  def max; end

  # Return the smallest [key, value] pair in the SplayTreeMap, or nil if the tree is empty.
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map["MA"] = "Massachusetts"
  #   map["GA"] = "Georgia"
  #   map.min #=> ["GA", "Georgia"]
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#132
  def min; end

  # Insert an item with an associated key into the SplayTreeMap, and returns the item inserted
  #
  # Complexity: amortized O(log n)
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts") #=> "Massachusetts"
  #   map.get("MA") #=> "Massachusetts"
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#34
  def push(key, value); end

  # Return the number of items in the SplayTreeMap.
  #
  #   map = Containers::SplayTreeMap.new
  #   map.push("MA", "Massachusetts")
  #   map.push("GA", "Georgia")
  #   map.size #=> 2
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#69
  def size; end

  private

  # Recursively determine height
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#253
  def height_recursive(node); end

  # Moves a key to the root, updating the structure in each step.
  #
  # source://algorithms//lib/containers/splay_tree_map.rb#210
  def splay(key); end
end

# source://algorithms//lib/containers/splay_tree_map.rb#19
class Containers::RubySplayTreeMap::Node < ::Struct
  # Returns the value of attribute key
  #
  # @return [Object] the current value of key
  def key; end

  # Sets the attribute key
  #
  # @param value [Object] the value to set the attribute key to.
  # @return [Object] the newly set value
  def key=(_); end

  # Returns the value of attribute left
  #
  # @return [Object] the current value of left
  def left; end

  # Sets the attribute left
  #
  # @param value [Object] the value to set the attribute left to.
  # @return [Object] the newly set value
  def left=(_); end

  # Returns the value of attribute right
  #
  # @return [Object] the current value of right
  def right; end

  # Sets the attribute right
  #
  # @param value [Object] the value to set the attribute right to.
  # @return [Object] the newly set value
  def right=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://algorithms//lib/containers/splay_tree_map.rb#266
Containers::SplayTreeMap = Containers::CSplayTreeMap

# A Stack is a container that keeps elements in a last-in first-out (LIFO) order. There are many
#     uses for stacks, including prefix-infix-postfix conversion and backtracking problems.
#
#     This implementation uses a doubly-linked list, guaranteeing O(1) complexity for all operations.
#
# source://algorithms//lib/containers/stack.rb#9
class Containers::Stack
  include ::Enumerable

  # Create a new stack. Takes an optional array argument to initialize the stack.
  #
  #   s = Containers::Stack.new([1, 2, 3])
  #   s.pop #=> 3
  #   s.pop #=> 2
  #
  # @return [Stack] a new instance of Stack
  #
  # source://algorithms//lib/containers/stack.rb#16
  def initialize(ary = T.unsafe(nil)); end

  # Adds an item to the stack.
  #
  #   s = Containers::Stack.new([1])
  #   s.push(2)
  #   s.pop #=> 2
  #   s.pop #=> 1
  #
  # source://algorithms//lib/containers/stack.rb#35
  def <<(obj); end

  # Iterate over the Stack in LIFO order.
  #
  # source://algorithms//lib/containers/stack.rb#63
  def each(&block); end

  # Returns true if the stack is empty, false otherwise.
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/stack.rb#58
  def empty?; end

  # Returns the next item from the stack but does not remove it.
  #
  #   s = Containers::Stack.new([1, 2, 3])
  #   s.next #=> 3
  #   s.size #=> 3
  #
  # source://algorithms//lib/containers/stack.rb#25
  def next; end

  # Removes the next item from the stack and returns it.
  #
  #   s = Containers::Stack.new([1, 2, 3])
  #   s.pop #=> 3
  #   s.size #=> 2
  #
  # source://algorithms//lib/containers/stack.rb#45
  def pop; end

  # Adds an item to the stack.
  #
  #   s = Containers::Stack.new([1])
  #   s.push(2)
  #   s.pop #=> 2
  #   s.pop #=> 1
  #
  # source://algorithms//lib/containers/stack.rb#35
  def push(obj); end

  # Return the number of items in the stack.
  #
  #   s = Containers::Stack.new([1, 2, 3])
  #   s.size #=> 3
  #
  # source://algorithms//lib/containers/stack.rb#53
  def size; end
end

# A suffix array enables fast substring search of a given string. An array of all possible substrings
#     is constructed and stored, and a binary search is then done to find a desired substring among those
#     stored. While more storage (and thus memory) is needed to create the SuffixArray, the advantage is
#     that substrings can be found in O(m log n) time, where m is the length of the substring to search for
#     and n is the total number of substrings.
#
# source://algorithms//lib/containers/suffix_array.rb#9
class Containers::SuffixArray
  # Creates a new SuffixArray with a given string. Object of any class implementing a #to_s method can
  # be passed in, such as integers.
  #
  # Complexity: O(n^2 log n)
  #
  #   s_array = Containers::SuffixArray.new("abracadabra")
  #   s_array["abra"] #=> true
  #
  #   number = Containers::SuffixArray.new(1234567)
  #   number[1] #=> true
  #   number[13] #=> false
  #
  # @raise [ArgumentError]
  # @return [SuffixArray] a new instance of SuffixArray
  #
  # source://algorithms//lib/containers/suffix_array.rb#21
  def initialize(string); end

  # Returns true if the substring occurs in the string, false otherwise.
  #
  # Complexity: O(m + log n)
  #
  #   s_array = Containers::SuffixArray.new("abracadabra")
  #   s_array.has_substring?("a") #=> true
  #   s_array.has_substring?("abra") #=> true
  #   s_array.has_substring?("abracadabra") #=> true
  #   s_array.has_substring?("acadabra") #=> true
  #   s_array.has_substring?("adabra") #=> true
  #   s_array.has_substring?("bra") #=> true
  #   s_array.has_substring?("bracadabra") #=> true
  #   s_array.has_substring?("cadabra") #=> true
  #   s_array.has_substring?("dabra") #=> true
  #   s_array.has_substring?("ra") #=> true
  #   s_array.has_substring?("racadabra") #=> true
  #   s_array.has_substring?("nope") #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/suffix_array.rb#51
  def [](substring); end

  # Returns true if the substring occurs in the string, false otherwise.
  #
  # Complexity: O(m + log n)
  #
  #   s_array = Containers::SuffixArray.new("abracadabra")
  #   s_array.has_substring?("a") #=> true
  #   s_array.has_substring?("abra") #=> true
  #   s_array.has_substring?("abracadabra") #=> true
  #   s_array.has_substring?("acadabra") #=> true
  #   s_array.has_substring?("adabra") #=> true
  #   s_array.has_substring?("bra") #=> true
  #   s_array.has_substring?("bracadabra") #=> true
  #   s_array.has_substring?("cadabra") #=> true
  #   s_array.has_substring?("dabra") #=> true
  #   s_array.has_substring?("ra") #=> true
  #   s_array.has_substring?("racadabra") #=> true
  #   s_array.has_substring?("nope") #=> false
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/suffix_array.rb#51
  def has_substring?(substring); end
end

# A Trie is a data structure that stores key value pairs in a tree-like fashion. It allows
#     O(m) lookup speed, where m is the length of the key searched, and has no chance of collisions,
#     unlike hash tables. Because of its nature, search misses are quickly detected.
#
#     Tries are often used for longest prefix algorithms, wildcard matching, and can be used to
#     implement a radix sort.
#
#     This implemention is based on a Ternary Search Tree.
#
# source://algorithms//lib/containers/trie.rb#11
class Containers::Trie
  # Create a new, empty Trie.
  #
  #   t = Containers::Trie.new
  #   t["hello"] = "world"
  #   t["hello"] #=> "world"
  #
  # @return [Trie] a new instance of Trie
  #
  # source://algorithms//lib/containers/trie.rb#17
  def initialize; end

  # Returns the value of the desired key, or nil if the key doesn't exist.
  #
  # Complexity: O(m) worst case
  #
  #   t = Containers::Trie.new
  #   t.get("hello") = "world"
  #   t.get("non-existant") #=> nil
  #
  # source://algorithms//lib/containers/trie.rb#57
  def [](key); end

  # Adds a key, value pair to the Trie, and returns the value if successful. The to_s method is
  # called on the parameter to turn it into a string.
  #
  # Complexity: O(m)
  #
  #   t = Containers::Trie.new
  #   t["hello"] = "world"
  #   t.push("hello", "world") # does the same thing
  #   t["hello"] #=> "world"
  #   t[1] = 1
  #   t[1] #=> 1
  #
  # source://algorithms//lib/containers/trie.rb#32
  def []=(key, value); end

  # Returns the value of the desired key, or nil if the key doesn't exist.
  #
  # Complexity: O(m) worst case
  #
  #   t = Containers::Trie.new
  #   t.get("hello") = "world"
  #   t.get("non-existant") #=> nil
  #
  # source://algorithms//lib/containers/trie.rb#57
  def get(key); end

  # Returns [char, value] if found
  #
  # source://algorithms//lib/containers/trie.rb#169
  def get_recursive(node, string, index); end

  # Returns true if the key is contained in the Trie.
  #
  # Complexity: O(m) worst case
  #
  # @return [Boolean]
  #
  # source://algorithms//lib/containers/trie.rb#44
  def has_key?(key); end

  # Returns the longest key that has a prefix in common with the parameter string. If
  # no match is found, the blank string "" is returned.
  #
  # Complexity: O(m) worst case
  #
  #   t = Containers::Trie.new
  #   t.push("Hello", "World")
  #   t.push("Hello, brother", "World")
  #   t.push("Hello, bob", "World")
  #   t.longest_prefix("Hello, brandon") #=> "Hello"
  #   t.longest_prefix("Hel") #=> ""
  #   t.longest_prefix("Hello") #=> "Hello"
  #
  # source://algorithms//lib/containers/trie.rb#77
  def longest_prefix(string); end

  # source://algorithms//lib/containers/trie.rb#136
  def prefix_recursive(node, string, index); end

  # Adds a key, value pair to the Trie, and returns the value if successful. The to_s method is
  # called on the parameter to turn it into a string.
  #
  # Complexity: O(m)
  #
  #   t = Containers::Trie.new
  #   t["hello"] = "world"
  #   t.push("hello", "world") # does the same thing
  #   t["hello"] #=> "world"
  #   t[1] = 1
  #   t[1] #=> 1
  #
  # source://algorithms//lib/containers/trie.rb#32
  def push(key, value); end

  # source://algorithms//lib/containers/trie.rb#152
  def push_recursive(node, string, index, value); end

  # Returns a sorted array containing strings that match the parameter string. The wildcard
  # characters that match any character are '*' and '.' If no match is found, an empty
  # array is returned.
  #
  # Complexity: O(n) worst case
  #
  #   t = Containers::Trie.new
  #   t.push("Hello", "World")
  #   t.push("Hilly", "World")
  #   t.push("Hello, bob", "World")
  #   t.wildcard("H*ll.") #=> ["Hello", "Hilly"]
  #   t.wildcard("Hel") #=> []
  #
  # source://algorithms//lib/containers/trie.rb#96
  def wildcard(string); end

  # source://algorithms//lib/containers/trie.rb#119
  def wildcard_recursive(node, string, index, prefix); end
end

# source://algorithms//lib/containers/trie.rb#104
class Containers::Trie::Node
  # @return [Node] a new instance of Node
  #
  # source://algorithms//lib/containers/trie.rb#107
  def initialize(char, value); end

  # Returns the value of attribute char.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def char; end

  # Sets the attribute char
  #
  # @param value the value to set the attribute char to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def char=(_arg0); end

  # Returns the value of attribute end.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def end; end

  # Sets the attribute end
  #
  # @param value the value to set the attribute end to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def end=(_arg0); end

  # @return [Boolean]
  #
  # source://algorithms//lib/containers/trie.rb#114
  def last?; end

  # Returns the value of attribute left.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def left=(_arg0); end

  # Returns the value of attribute mid.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def mid; end

  # Sets the attribute mid
  #
  # @param value the value to set the attribute mid to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def mid=(_arg0); end

  # Returns the value of attribute right.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def right=(_arg0); end

  # Returns the value of attribute value.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://algorithms//lib/containers/trie.rb#105
  def value=(_arg0); end
end
