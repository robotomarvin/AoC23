# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/algorithms/all/algorithms.rbi
#
# algorithms-1.0.1

module Algorithms::Search
  def kmp_search(substring); end
  def self.binary_search(container, item); end
  def self.kmp_search(string, substring); end
end
class Containers::Heap
  def <<(key, value = nil); end
  def cascading_cut(node); end
  def change_key(key, new_key, delete = nil); end
  def clear; end
  def consolidate; end
  def cut(x, y); end
  def delete(key); end
  def empty?; end
  def has_key?(key); end
  def initialize(ary = nil, &block); end
  def length; end
  def link_nodes(child, parent); end
  def merge!(otherheap); end
  def next!; end
  def next; end
  def next_key; end
  def pop; end
  def push(key, value = nil); end
  def size; end
  include Enumerable
end
class Containers::Heap::Node
  def child; end
  def child=(arg0); end
  def degree; end
  def degree=(arg0); end
  def initialize(key, value); end
  def key; end
  def key=(arg0); end
  def left; end
  def left=(arg0); end
  def marked; end
  def marked=(arg0); end
  def marked?; end
  def parent; end
  def parent=(arg0); end
  def right; end
  def right=(arg0); end
  def value; end
  def value=(arg0); end
end
class Containers::MaxHeap < Containers::Heap
  def initialize(ary = nil); end
  def max!; end
  def max; end
end
class Containers::MinHeap < Containers::Heap
  def initialize(ary = nil); end
  def min!; end
  def min; end
end
module Algorithms::Sort
  def self.bubble_sort(container); end
  def self.comb_sort(container); end
  def self.dualpivot(container, left = nil, right = nil, div = nil); end
  def self.dualpivot_swap(container, i, j); end
  def self.dualpivotquicksort(container); end
  def self.heapsort(container); end
  def self.insertion_sort(container); end
  def self.merge(left, right); end
  def self.mergesort(container); end
  def self.partition(data, left, right); end
  def self.quicksort(container); end
  def self.selection_sort(container); end
  def self.shell_sort(container); end
end
module Algorithms::String
  def self.levenshtein_dist(arg0, arg1); end
end
class Containers::CDeque
  def back; end
  def clear; end
  def each; end
  def each_backward; end
  def each_forward; end
  def empty?; end
  def front; end
  def initialize(*arg0); end
  def length; end
  def pop_back; end
  def pop_front; end
  def push_back(arg0); end
  def push_front(arg0); end
  def reverse_each; end
  def size; end
end
class Containers::RubyDeque
  def back; end
  def clear; end
  def each; end
  def each_backward; end
  def each_forward; end
  def empty?; end
  def front; end
  def initialize(ary = nil); end
  def length; end
  def pop_back; end
  def pop_front; end
  def push_back(obj); end
  def push_front(obj); end
  def reverse_each; end
  def size; end
  include Enumerable
end
class Containers::RubyDeque::Node < Struct
  def left; end
  def left=(_); end
  def obj; end
  def obj=(_); end
  def right; end
  def right=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Containers::Stack
  def <<(obj); end
  def each(&block); end
  def empty?; end
  def initialize(ary = nil); end
  def next; end
  def pop; end
  def push(obj); end
  def size; end
  include Enumerable
end
class Containers::Queue
  def <<(obj); end
  def each(&block); end
  def empty?; end
  def initialize(ary = nil); end
  def next; end
  def pop; end
  def push(obj); end
  def size; end
  include Enumerable
end
class Containers::PriorityQueue
  def clear; end
  def delete(priority); end
  def empty?; end
  def has_priority?(priority); end
  def initialize(&block); end
  def length; end
  def next!; end
  def next; end
  def pop; end
  def push(object, priority); end
  def size; end
  include Enumerable
end
class Containers::CRBTreeMap
  def [](arg0); end
  def []=(arg0, arg1); end
  def delete(arg0); end
  def delete_max; end
  def delete_min; end
  def each; end
  def empty?; end
  def get(arg0); end
  def has_key?(arg0); end
  def height; end
  def initialize; end
  def max_key; end
  def min_key; end
  def push(arg0, arg1); end
  def size; end
end
class Containers::RubyRBTreeMap
  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def delete_max; end
  def delete_max_recursive(node); end
  def delete_min; end
  def delete_min_recursive(node); end
  def delete_recursive(node, key); end
  def each; end
  def empty?; end
  def get(key); end
  def get_recursive(node, key); end
  def has_key?(key); end
  def height; end
  def height_black; end
  def height_black=(arg0); end
  def initialize; end
  def insert(node, key, value); end
  def isred(node); end
  def max_key; end
  def max_recursive(node); end
  def min_key; end
  def min_recursive(node); end
  def push(key, value); end
  def size; end
  include Enumerable
end
class Containers::RubyRBTreeMap::Node
  def color; end
  def color=(arg0); end
  def colorflip; end
  def fixup; end
  def height; end
  def height=(arg0); end
  def initialize(key, value); end
  def key; end
  def key=(arg0); end
  def left; end
  def left=(arg0); end
  def move_red_left; end
  def move_red_right; end
  def red?; end
  def right; end
  def right=(arg0); end
  def rotate_left; end
  def rotate_right; end
  def size; end
  def size=(arg0); end
  def update_size; end
  def value; end
  def value=(arg0); end
end
class Containers::CSplayTreeMap
  def [](arg0); end
  def []=(arg0, arg1); end
  def clear; end
  def delete(arg0); end
  def each; end
  def empty?; end
  def get(arg0); end
  def has_key?(arg0); end
  def height; end
  def initialize; end
  def max_key; end
  def min_key; end
  def push(arg0, arg1); end
  def size; end
end
class Containers::RubySplayTreeMap
  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def each; end
  def get(key); end
  def has_key?(key); end
  def height; end
  def height_recursive(node); end
  def initialize; end
  def max; end
  def min; end
  def push(key, value); end
  def size; end
  def splay(key); end
  include Enumerable
end
class Containers::RubySplayTreeMap::Node < Struct
  def key; end
  def key=(_); end
  def left; end
  def left=(_); end
  def right; end
  def right=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
end
class Containers::SuffixArray
  def [](substring); end
  def has_substring?(substring); end
  def initialize(string); end
end
class Containers::Trie
  def [](key); end
  def []=(key, value); end
  def get(key); end
  def get_recursive(node, string, index); end
  def has_key?(key); end
  def initialize; end
  def longest_prefix(string); end
  def prefix_recursive(node, string, index); end
  def push(key, value); end
  def push_recursive(node, string, index, value); end
  def wildcard(string); end
  def wildcard_recursive(node, string, index, prefix); end
end
class Containers::Trie::Node
  def char; end
  def char=(arg0); end
  def end; end
  def end=(arg0); end
  def initialize(char, value); end
  def last?; end
  def left; end
  def left=(arg0); end
  def mid; end
  def mid=(arg0); end
  def right; end
  def right=(arg0); end
  def value; end
  def value=(arg0); end
end
class Containers::KDTree
  def build_tree(points, depth = nil); end
  def check_nearest(nearest, node, target, k_nearest); end
  def distance2(node, target); end
  def find_nearest(target, k_nearest); end
  def initialize(points); end
  def nearest(node, target, k_nearest, depth); end
end
class Containers::KDTree::Node < Struct
  def coords; end
  def coords=(_); end
  def id; end
  def id=(_); end
  def left; end
  def left=(_); end
  def right; end
  def right=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
module Algorithms
end
module Containers
end
